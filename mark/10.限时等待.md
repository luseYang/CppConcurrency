# 限时等待

阻塞调用会将线程挂起一段时间（并不确定时间），直到对应的事件发生。通常情况下，这样的方式会很好，到那时在一些情况下，我们需要自己限定线程等待的时间，因为无限期的等待事件发生可能会导致性能下降或者浪费资源。一个常见的例子是在很多网络库中的 `connect` 函数，这个函数的调用是阻塞的，但是也是显示的，一定时间内没有连接到服务器就不会继续阻塞了，进行其他处理比如说抛出异常。

这里学习两种指定超时的方法，一种是 **“时间段”**，另一种是 **“时间点”**，其实就是之前的 `std::this::thread::sleep_for` 与 `std::this_thread::sleep_until` 的区别。前者是需要指定等待一段时间，比如 10ms，后者是指定等待到一个具体的时间点（比如到 `2024-10-10T20:16:15.123`）。多数函数都对两种超时方式进行处理。**处理持续时间的函数以 `_for` 作为后缀处理绝对时间的函数以 `_until` 作为后缀**。

条件变量 `std::condition_variable` 的等待函数，也有两个超时的版本 `wait_for` 和 `wait_until`。它们和我们先前讲的 `wait` 成员函数一样有两个重载，可以选择是否传递一个谓词。它们相比于 `wait` 多了一个解除阻塞的可能，即：超过指定的时长或抵达指定的时间点。

在讲述它的使用细节之前，我们还是要来先聊一下 C++ 中的时间库（chrono），指定时间的方式，它较为麻烦。我们分：***时钟（clock）***、***时间段（duration）***、***时间点（time point）*** 三个阶段稍微介绍一下。

# 时钟

在 C++ 标准库中，时钟被视为时间信息的来源。C++ 定义了很多种时间类型，每种时钟类型都提供了四种不同的信息：

- 当前时间
- 时间类型
- 时钟节拍
- 稳定时钟

当前时间可以通过静态成员函数 `now` 获取，例如，`std::chrono::system_clock::now()` 会返回系统的当前时间。特定的时间点则可以通过 `time_point` 来指定。`system_clock::now()` 的返回类型就是 `time_point`。

时钟节拍器被指定为 1/x（x 在不同硬件上有不同的值）秒，这是由时间周期所决定的。假设一个时钟一秒由25个节拍，英雌一个周期为 `std::ratio<1, 25>`。当一个时钟的时钟节拍每 2.5 秒一次，周期就可以表示为 `std::ratio<5, 2>`。

类模版 `std::chrono::duration` 表示时间间隔。

```cpp
template<class Rep, class Period = std::ratio<1>>
class duration;
```

> `std::ratio` 是一个分数类模板，它有两个非类型模板参数，也就是分子与分母，分母有默认实参 1，所以 `std::ratio<1>` 等价于 `std::ratio<1, 1>`。

如你所见，它默认的时钟节拍是 1，这是一个很重要的类，标准库通过它定义了很多的时间类型，比如 `std::chrono::minutes` 是分钟类型，那么它的 `Period` 就是 `std::ratio<60>`，因为一分钟等于 60 秒。

```cpp
using minutes      = duration<int, ratio<60>>;
```

稳定时钟（Steady Clock）是指提供稳定、持续递增的时间流逝信息的时钟。它的特点是不受系统时间调整或变化的影响，即使在系统休眠或时钟调整的情况下，它也能保持稳定。在 C++ 标准库中，`std::chrono::steady_clock` 就是一个稳定时钟。它通常用于测量时间间隔和性能计时等需要高精度和稳定性的场景。可以通过 `is_steady` 静态常量判断当前时钟是否是稳定时钟。

稳定时钟的主要优点在于，它可以提供相对于起始时间的稳定的递增时间，因此适用于需要保持时间顺序和不受系统时间变化影响的应用场景。相比之下，像 `std::chrono::system_clock` 这样的系统时钟可能会受到系统时间调整或变化的影响，因此在某些情况下可能不适合对时间间隔进行精确测量。

不管使用哪种时钟获取时间，C++ 都提供了函数，可以将时间点转换为 `time_t` 类型的值：

```cpp
auto now = std::chrono::system_clock::now();
time_t now_time = std::chrono::system_clock::to_time_t(now);
std::cout << "Current time:\t" << std::put_time(std::localtime(&now_time), "%H:%M:%S\n");

auto now2 = std::chrono::steady_clock::now();
now_time = std::chrono::system_clock::to_time_t(now);
std::cout << "Current time:\t" << std::put_time(std::localtime(&now_time), "%H:%M:%S\n");
```

C++ 的时间库极其繁杂，主要在于类型之多，以及实现之复杂。根据我们的描述，了解基本构成、概念、使用，即可。

# 时间段

时间部分最简单的就是时间段，主要的内容欧式我们上面讲的类模板 `std::chrono::duration`，他对于时间段进行处理

它的第一个参数是类型表示，第二个参数就是先前提到的“节拍”，需要传递一个 `std::ratio` 类型，也就是一个时钟所用的秒数。

标准库在 `std::chrono` 命名空间内为时间段提供了一系列的类型，它们都是通过 `std::chrono::duration` 定义的别名：

```cpp
using nanoseconds  = duration<long long, nano>;
using microseconds = duration<long long, micro>;
using milliseconds = duration<long long, milli>;
using seconds      = duration<long long>;
using minutes      = duration<int, ratio<60>>;
using hours        = duration<int, ratio<3600>>;
// CXX20
using days   = duration<int, ratio_multiply<ratio<24>, hours::period>>;
using weeks  = duration<int, ratio_multiply<ratio<7>, days::period>>;
using years  = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>;
using months = duration<int, ratio_divide<years::period, ratio<12>>>;
```

如果没有指明 `duration` 的第二个非类型模版参数，那么代表默认 `std::ratio<1>` ，比如 `seconds` 就是1秒。

为了方便使用，在 C++14 标准库正价了时间字面量，存在与 `std::chrono_literals` 命名空间中

```cpp
using namespace std::chrono_literals;

auto one_nanosecond = 1ns;
auto one_microsecond = 1us;
auto one_millisecond = 1ms;
auto one_second = 1s;
auto one_minute = 1min;
auto one_hour = 1h;
```

当不要求截断值的情况下（时转换为秒时没问题的，但反过来不行）时间段有隐式转换，显式转换可以由 `std::chrono::duration_cast<>` 来完成。

```cpp
std::chrono::milliseconds ms{ 3999 };
std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(ms);
std::cout << s.count() << '\n';
```

这里的结果是截断的，而不会进行所谓的四舍五入，3999 毫秒，也就是 3.999 秒最终的值是 3。

> 很多时候这并不是我们想要的，比如我们想要的其实是输出 3.999 秒，而不是 3 秒 或者 3999 毫秒。`seconds` 是 `duration<long long>` 这意味着它无法接受浮点数，我们直接改成 `duration<double>` 即可
> ```cpp
> std::chrono::duration<double> s = std::chrono::duration_cast<std::chrono::duration<double>>(ms);
> ```
>
> 当然了，这样写很冗余，并且这种形式的转换是可以直接隐式的，也就是其实我们可以直接：
>
> ```cpp
> std::chrono::duration<double> s = ms;
> ```
>
> 无需使用 `duration_cast`，可以直接隐式转换
> 另外我们用的 `duration` 都是省略了 `ratio` 的，其实默认类型就是 `ratio<1>`，代表一秒。参见源码声明：
>
> ```cpp
> _EXPORT_STD template <class _Rep, class _Period = ratio<1>>
> class duration;
> ```

时间库支持四则运算，可以对两个时间段进行加减乘除。时间段对象可以通过 `count()` 成员函数获得计次数。例如 `std::chrono::milliseconds{123}.count()` 的结果就是 123。

基于时间段的等待都是由 `std::chrono::duration<>` 来完成。例如：等待一个 `future` 对象在 35 毫秒内变为就绪状态：

```cpp
std::future<int> future = std::async([] {return 6; });
if (future.wait_for(35ms) == std::future_status::ready)
    std::cout << future.get() << '\n';
```

`wait_for`： 等待结果，如果在指定的超时间隔后仍然无法得到结果，则返回。它的返回类型是一个枚举类 `std::future_status`，三个枚举项分别表示三种 `future` 状态。

`deferred`：共享状态持有的函数正在延迟运行，结果将仅在明确请求时计算
`ready`：共享状态就绪
`timeout`：共享状态在经过指定的等待事件内仍未就绪

`timeout` 超时，也很好理解，那我们就提一下 `deferred`：

```cpp
auto future = std::async(std::launch::deferred, []{});
if (future.wait_for(35ms) == std::future_status::deferred)
    std::cout << "future_status::deferred " << "正在延迟执行\n";
future.wait(); // 在 wait() 或 get() 调用时执行，不创建线程
```

# 时间点

时间点可以用 `std::chrono::time_point<>` 来表示，第一个模版参数用来指定使用的始终，第二个模版参数用来表示时间单位（`std::chrono::duration<>`）。时间点顾名思义就是时间中的一个点，在 C++ 中用于表达当前时间，先前提到的静态成员函数 now() 获取当前时间，它们的返回类型都是 `std::chrono::time_point`。

```cpp
template<
    class Clock,
    class Duration = typename Clock::duration
> class time_point;
```



