# std::thread 的构造-源码解析

让我们来了解一下 C++11 引入的 `std::thread` 是如何构造的，如何创建线程以及传递参数。

## std::thread 的数据成员

`std::thread` 只保有一个私有数据成员 `_Thr`：

```cpp
private：
    _Thrd_t _Thr;
```

`_Thr_t` 是一个结构体，它保有两个数据成员：

```cpp
using _Thrd_id_t = unsigned int;
struct _Thrd_t { // thread identifier for Win32
    void* _Hnd; // Win32 HANDLE
    _Thrd_id_t _Id;
};
```

这个结构体的 `_Hnd` 成员是指向线程的句柄，`_Id` 成员就是保有线程的 ID。

在 64 位操作系统，因为内存对齐，指针 8 ，无符号 `int` 4，这个结构体 `_Thrd_t` 就是占据 16 个字节。也就是说 `sizeof(std::thread)` 的结果应该为 16。

## `std::thread` 的构造函数

`std::thread` 有四个构造函数，分别是：

1. 默认构造函数，构造不关联线程的新 `std::thread` 对象。

```cpp
thread() noexcept : _Thr{} {}
```

值初始化了数据成员 `_Thr`，这里的效果相当于给其成员 `_Hnd` 和 `_Id` 都进行零初始化。

2. 移动构造函数，转移线程的所有权，构造 `other` 关联的执行线程的 `std::thread` 对象。此调用后 `other` 不再表示执行线程失去了线程的所有权。

```cpp
thread(thread&& _Other) noexcept : _Thr(_STD exchange(_Other._Thr, {})) {}
```

`_STD` 是一个宏，展开就是 `::std::`，也就是 `::std::exchange`，将 `_Other._Thr` 赋为 `{}` （也就是置空），返回 `_Other._Thr` 的旧值用以初始化当前对象的数据成员 `_Thr`。

3. 复制构造函数被定义为弃置的，`std::thread` 不可复制。两个` std::thread` 不可表示一个线程，`std::thread` 对线程资源是独占所有权。

```cpp
thread(const thread&) = delete;
```

4. 构造新的 `std::thread` 对象并将它与执行线程关联。表示新的执行线程开始执行。

```cpp
template <class _Fn, class... _Args, enable_if_t<!is_same_v<_Remove_cvref_t<_Fn>, thread>, int> = 0>
    _NODISCARD_CTOR_THREAD explicit thread(_Fn&& _Fx, _Args&&... _Ax) {
        _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...);
    }
```

---

第四个构造函数较为复杂，且是我们本章重点，需要详细讲解。
































