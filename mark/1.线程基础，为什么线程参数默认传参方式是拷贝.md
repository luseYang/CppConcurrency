# 线程发起

线程发起顾名思义就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程

```cpp
#include <iostream>
#include <thread>
#include <string>

void f(std::string s) {
	std::cout << s << '\n';
}

int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
}
```

但是如果直接在 `main` 函数中运行这个 `t1` 的话，我们并没有将这个线程挂起，也许可以打印，也许直接退出，因为主线程这时候已经结束了，但子线程还在运行，程序就会崩溃。

我们可以在主线程中调用 `t1` 之后，

```cpp
#include <iostream>
#include <thread>
#include <string>

void f(std::string s) {
	std::cout << s << '\n';
}

int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```

我们让主线程睡一会，这样可以吗？发现还是崩溃，为什么呢？

因为当编译器发现我们一没有让主线程调用 `join()` 等待，二没有调用 `detach()` 让线程分离运行，在主线程结束回收资源的时候，就会调用主线程的析构函数，当中有一个 `terminate()` 函数，这个函数的强制终止会调用 `assert` 断言强制崩溃。

所以我们需要：

```cpp
int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    std::this_thread::sleep_for(std::chrono::seconds(1));
    t1.join();
}
```

`t1.join()` 让主线程必须等待子线程执行完才能继续往下执行。

# 将仿函数作为参数

`std::thread` 支持的形式还有很多，只要是[可调用(Callable)对象](https://zh.cppreference.com/w/cpp/named_req/Callable)即可

```cpp
class Task {
public:
	void operator()(){
		std::cout << "Task called" << '\n;
	}
};
```

```cpp
int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    t1.join();
	std::thread t2(Task());
	t2.join();		// 编译报错
}
```

但这个为什么报错呢，因为我们显然没办法直接像函数使用函数名一样，使用“类名”，**函数名可以隐式转换到指向它的函数指针**，而类名可不会直接变成对象，我们想使用 `Task` 自然就得构造对象了

```cpp
std::thread t2{ Task{} };
t2.join();
```

直接创建临时对象即可，可以简化代码并避免引入不必要的局部对象。

不过有件事情需要注意，**当我们使用函数对象用于构造 `std::thread` 的时候，如果你传入的是一个临时对象，且使用的都是 “()”小括号初始化，那么编译器会将此语法解析为函数声明。**

```cpp
std::thread t2(Task()); // 函数声明
```

这被编译器解析为函数声明，是一个返回类型为 `std::thread`，函数名为 `t2`，参数接受一个，返回值为 `Task` 的空参的函数指针类型，也就是 `Task(*)()`。

之所以我们看着抽象是因为这里的形参是无名的，且写了个函数类型。

用一个简单的示例为你展示：

```cpp
void h(int(int));         //#1 声明
void h(int (*p)(int)){}   //#2 定义
```

即使我还没有为你讲述概念，我相信你也发现了，`#1` 和 `#2` 的区别无非是，`#1` 省略了形参的名称，还有它的形参是函数类型而不是函数指针类型，没有 `*`。

在确定每个形参的类型后，类型是 “`T` 的数组”或某个函数类型 `T` 的形参会调整为具有类型“指向 `T` 的指针”。[文档](https://zh.cppreference.com/w/cpp/language/function#.E5.BD.A2.E5.8F.82.E7.B1.BB.E5.9E.8B.E5.88.97.E8.A1.A8)。

显然，`int(int)` 是一个函数类型，它被调整为了一个指向这个函数类型的指针类型。

```cpp
std::thread t( Task() );                    // #1 函数声明
std::thread t( Task (*p)() ){ return {}; }  // #2 函数定义
```

`#2` 我们写出了函数形参名称 `p`，再将函数类型写成函数指针类型，事实上完全等价。我相信，这样，也就足够了。

所以总而言之，建议使用 `{}` 进行初始化，这是好习惯，大多数时候它是合适的。

# lambda 表达式作为参数

C++11 引入的 `Lambda` 表达式，同样可以作为构造 `std::thread` 的参数，因为 `Lambda` 本身就是生成了一个函数对象，它自身就是类类型。

```cpp
#include <iostream>
#include <thread>

int main(){
    std::thread thread{ [] {std::cout << "Hello World!\n"; } };
    thread.join();
}
```

# 使用 `detach` 分离线程

启动线程后（也就是构造 `std::thread` 对象）我们必须在线程对象的生存期结束之前，即 `std::thread::~thread` 调用之前，决定它的执行策略，是 `join()`（合并）还是 `detach()`（分离）。

```cpp
std::thread t3([]() {
		std::cout << "lambda" << '\n';
		});
t3.detach();
```

我们先前使用的就是 `join()`，我们聊一下 `detach()`，当 `std::thread` 线程对象调用了 `detach()`，那么就是线程对象放弃了对线程资源的所有权，不再管理此线程，允许此线程独立的运行，在线程退出时释放所有分配的资源。

放弃了对线程资源的所有权，也就是线程对象没有关联活跃线程了，此时 `joinable` 为 `false`(`joinable` 是一个检查线程是否有能力与主线程同步的成员函数，如果线程是可连接的，即线程已经启动且尚未与主线程同步（还没有被 `join()` 或 `detach()`）返回 `true`。如果线程是不可连接的，通常发生在以下几种情况下：线程对象未被初始化（默认构造的 `std::thread` 对象）。线程已经结束且调用了 `join()`。线程已经被分离（调用了 `detach()`），返回 `false`)。

在单线程的代码中，对象销毁之后再去访问，会产生未定义行为，多线程增加了这个问题发生的几率。

比如函数结束，那么函数局部对象的生存期都已经结束了，都被销毁了，此时线程函数还持有函数局部对象的指针或引用。

```cpp
#include <iostream>
#include <thread>

struct func {
    int& m_i;
    func(int& i) :m_i{ i } {}
    void operator()(int n)const {
        for (int i = 0; i <= n; ++i) {
            m_i += i;           // 可能悬空引用
        }
    }
};

int main(){
    int n = 0;
    std::thread my_thread{ func{n},100 };
    my_thread.detach();        // 分离，不等待线程结束
}                              // 分离的线程可能还在运行
```

1. 主线程（`main`）创建局部对象 `n`、创建线程对象 `my_thread` 启动线程，执行任务 `func{n}`，局部对象 `n` 的引用被子线程持有。传入 `100` 用于调用 `func` 的 `operator(int)`。

2. `my_thread.detach();`，`joinable()` 为 `false`。线程分离，线程对象不再持有线程资源，线程独立的运行。

3. 主线程不等待，此时分离的子线程可能没有执行完毕，但是主线程（`main`）已经结束，局部对象 n 生存期结束，被销毁，而此时子线程还持有它的引用，访问悬空引用，造成未定义行为。`my_thread` 已经没有关联线程资源，正常析构，没有问题。

解决方法很简单，将 `detach()` 替换为 `join()`。

> 通常非常不推荐使用 `detach()`，因为程序员必须确保所有创建的线程正常退出，释放所有获取的资源并执行其它必要的清理操作。这意味着通过调用 `detach()` 放弃线程的所有权不是一种选择，因此 `join` 应该在所有场景中使用。 一些老式特殊情况不聊。



# 异常处理

顺带的，我们还得处理线程运行后的异常问题，举个例子：你在一个函数中构造了一个 `std::thread` 对象，线程开始执行，函数继续执行下面别的代码，但是如果抛出了异常呢？下面我的 `join()` 就会被跳过。

```cpp
std::thread my_thread{func{n},10};
//todo.. 抛出异常的代码
my_thread.join();
```

所以为了避免程序被抛出的异常终止，我们需要再处理异常的时候手动调用 `join()`，从而避免线程对象析构产生问题。

```cpp
struct func; // 复用之前
void f(){
    int n = 0;
    std::thread t{ func{n},10 };
    try{
        // todo.. 一些当前线程可能抛出异常的代码
        f2();
    }
    catch (...){
        t.join(); // 1
        throw;
    }
    t.join();    // 2
}
```

既然主线程退出了，我们为什么还需要管理子线程？

当我们设计一个充值模块的时候，充值在主线程，入库在子线程，如果充值之后主线程崩掉了，不进行异常处理的话会导致入库操作的子线程也被回收，入库失败导致丢失日志或数据。

# RAII

上面的写法都太过冗余了，我们有没有什么办法可以在知道这个线程想要被回收之前，再去 `join` 他呢？包有的，利用 C++ 的RAII思想，资源获取即初始化。简单的说是：构造函数申请资源，析构函数释放资源，让对象的生命周期和资源绑定。当异常抛出时，C++ 会自动调用对象的析构函数。

我们可以提供一个类，在析构函数中使用 `join()` 确保线程执行完成，线程对象正常析构。

```cpp
class thread_guard{
    std::thread& m_t;
public:
    explicit thread_guard(std::thread& t) :m_t{ t } {}
    ~thread_guard(){
        std::puts("析构");     // 打印日志 不用在乎
        if (m_t.joinable()) { // 线程对象当前关联了活跃线程
            m_t.join();
        }
    }
    thread_guard(const thread_guard&) = delete;
    thread_guard& operator=(const thread_guard&) = delete;
};

void f(){
    int n = 0;
    std::thread t{ func{n},10 };
    thread_guard g(t);
    f2(); // 可能抛出异常
}
```




















