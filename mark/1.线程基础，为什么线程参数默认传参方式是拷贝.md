# 线程发起

线程发起顾名思义就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程

```cpp
#include <iostream>
#include <thread>
#include <string>

void f(std::string s) {
	std::cout << s << '\n';
}

int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
}
```

但是如果直接在 `main` 函数中运行这个 `t1` 的话，我们并没有将这个线程挂起，也许可以打印，也许直接退出，因为主线程这时候已经结束了，但子线程还在运行，程序就会崩溃。

我们可以在主线程中调用 `t1` 之后，

```cpp
#include <iostream>
#include <thread>
#include <string>

void f(std::string s) {
	std::cout << s << '\n';
}

int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```

我们让主线程睡一会，这样可以吗？发现还是崩溃，为什么呢？

因为当编译器发现我们一没有让主线程调用 `join()` 等待，二没有调用 `detach()` 让线程分离运行，在主线程结束回收资源的时候，就会调用主线程的析构函数，当中有一个 `terminate()` 函数，这个函数的强制终止会调用 `assert` 断言强制崩溃。

所以我们需要：

```cpp
int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    std::this_thread::sleep_for(std::chrono::seconds(1));
    t1.join();
}
```

`t1.join()` 让主线程必须等待子线程执行完才能继续往下执行。

# 线程等待

