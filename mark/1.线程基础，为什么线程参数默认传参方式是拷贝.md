# 线程发起

线程发起顾名思义就是启动一个线程，C++11标准统一了线程操作，可以在定义一个线程变量后，该变量启动线程执行回调逻辑。如下即可发起一个线程

```cpp
#include <iostream>
#include <thread>
#include <string>

void f(std::string s) {
	std::cout << s << '\n';
}

int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
}
```

但是如果直接在 `main` 函数中运行这个 `t1` 的话，我们并没有将这个线程挂起，也许可以打印，也许直接退出，因为主线程这时候已经结束了，但子线程还在运行，程序就会崩溃。

我们可以在主线程中调用 `t1` 之后，

```cpp
#include <iostream>
#include <thread>
#include <string>

void f(std::string s) {
	std::cout << s << '\n';
}

int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
```

我们让主线程睡一会，这样可以吗？发现还是崩溃，为什么呢？

因为当编译器发现我们一没有让主线程调用 `join()` 等待，二没有调用 `detach()` 让线程分离运行，在主线程结束回收资源的时候，就会调用主线程的析构函数，当中有一个 `terminate()` 函数，这个函数的强制终止会调用 `assert` 断言强制崩溃。

所以我们需要：

```cpp
int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    std::this_thread::sleep_for(std::chrono::seconds(1));
    t1.join();
}
```

`t1.join()` 让主线程必须等待子线程执行完才能继续往下执行。

# 将仿函数作为参数

`std::thread` 支持的形式还有很多，只要是[可调用(Callable)对象](https://zh.cppreference.com/w/cpp/named_req/Callable)即可

```cpp
class Task {
public:
	void operator()(){
		std::cout << "Task called" << '\n;
	}
};
```

```cpp
int main() {
	std::string s = "hello\n";
	std::thread t1{ f, s };
    t1.join();
	std::thread t2(Task());
	t2.join();		// 编译报错
}
```

但这个为什么报错呢，因为我们显然没办法直接像函数使用函数名一样，使用“类名”，**函数名可以隐式转换到指向它的函数指针**，而类名可不会直接变成对象，我们想使用 `Task` 自然就得构造对象了

```cpp
std::thread t2{ Task{} };
t2.join();
```

直接创建临时对象即可，可以简化代码并避免引入不必要的局部对象。

不过有件事情需要注意，**当我们使用函数对象用于构造 `std::thread` 的时候，如果你传入的是一个临时对象，且使用的都是 “()”小括号初始化，那么编译器会将此语法解析为函数声明。**

```cpp
std::thread t2(Task()); // 函数声明
```

这被编译器解析为函数声明，是一个返回类型为 `std::thread`，函数名为 `t2`，接受一个，返回 `Task` 的空参的函数指针类型，也就是 `Task(*)()`。

之所以我们看着抽象是因为这里的形参是无名的，且写了个函数类型。

用一个简单的示例为你展示：

```cpp
void h(int(int));         //#1 声明
void h(int (*p)(int)){}   //#2 定义
```

即使我还没有为你讲述概念，我相信你也发现了，`#1` 和 `#2` 的区别无非是，`#1` 省略了形参的名称，还有它的形参是函数类型而不是函数指针类型，没有 `*`。

在确定每个形参的类型后，类型是 “`T` 的数组”或某个函数类型 `T` 的形参会调整为具有类型“指向 `T` 的指针”。[文档](https://zh.cppreference.com/w/cpp/language/function#.E5.BD.A2.E5.8F.82.E7.B1.BB.E5.9E.8B.E5.88.97.E8.A1.A8)。

显然，`int(int)` 是一个函数类型，它被调整为了一个指向这个函数类型的指针类型。

```cpp
std::thread t( Task() );                    // #1 函数声明
std::thread t( Task (*p)() ){ return {}; }  // #2 函数定义
```

`#2` 我们写出了函数形参名称 `p`，再将函数类型写成函数指针类型，事实上完全等价。我相信，这样，也就足够了。

所以总而言之，建议使用 `{}` 进行初始化，这是好习惯，大多数时候它是合适的。


















