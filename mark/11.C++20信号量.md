# C++20 信号量

C++20 引入了信号量，这是一个同步设施，信号量源自操作系统，在各种编程语言中都有自己的抽象实现，C++算挺晚引进的了。

信号量是一个非常**轻量简单**的同步设施，他维护一个计数，这个技术不能小于 0，信号量提供两种基本操作：**释放**（增加技术），**等待**（减少计数）如果当前信号量的计数值为0，那么执行**等待**操作的线程将会**一直阻塞**直到技术大于0，也就是其他线程执行了**释放**操作。

C++ 提供了两个信号量类型：`std::counting_semaphore` 和 `std::binary_semaphore`，定于在 `<semaphore>` 中

`binary_semaphore` 只是 `counting_semaphore` 的一个特化别名，*如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore），这就是这个类型名字的由来。* 

```cpp
using binary_semaphore = counting_semaphore<1>;
```

好了，我们举一个简单的例子来使用一下：

```cpp
#include <iostream>
#include <semaphore>
#include <thread>
#include <chrono>

using namespace std::chrono_literals;

std::binary_semaphore smph_singal_main_to_thread{ 0 };
std::binary_semaphore smph_singal_thread_to_main{ 0 };

void thread_proc() {
	smph_singal_main_to_thread.acquire();
	std::cout << "[线程] 获得信号" << '\n';

	std::this_thread::sleep_for(3s);

	std::cout << "[线程] 发送信号" << '\n';
	smph_singal_thread_to_main.release();
}

int main() {
	std::jthread thr_worker{ thread_proc };

	std::cout << "[主] 发送信号" << '\n';
	smph_singal_main_to_thread.release();

	smph_singal_thread_to_main.acquire();
	std::cout << "[主] 获得信号" << '\n';
	
}
```

> 输出结果：
> [主] 发送信号
> [线程] 获得信号
> [线程] 发送信号
> [主] 获得信号

`acquire` 函数就是我们先前说的“等待”（**原子地减少计数**），`release` 函数就是"释放"（**原子地增加计数**）。

---

信号量主要用于*发信/提醒*而非排斥，通过初始化该信号量为 0 从而阻塞尝试 `acquire()` 的接收者，直到提醒者通过调用 `release(n)` “发信”。在此方面可把信号量当作**条件变量的替代品，通常它有更好的性能**。

假设我们有一个 Web 服务器，它只能处理有限数量的并发请求。为了防止服务器过载，我们可以**使用信号量来限制并发请求的数量**。

```cpp
// 定义一个信号量，最大并发数为 3
std::counting_semaphore<3> semaphore{ 3 };

void handle_request(int request_id) {
    // 请求到达，尝试获取信号量
    std::cout << "进入 handle_request 尝试获取信号量\n";

    semaphore.acquire();

    std::cout << "成功获取信号量\n";

    // 此处延时三秒可以方便测试，会看到先输出 3 个“成功获取信号量”，因为只有三个线程能成功调用 acquire，剩余的会被阻塞
    std::this_thread::sleep_for(3s);

    // 模拟处理时间
    std::random_device rd;
    std::mt19937 gen{ rd() };
    std::uniform_int_distribution<> dis(1, 5);
    int processing_time = dis(gen);
    std::this_thread::sleep_for(std::chrono::seconds(processing_time));

    std::cout << std::format("请求 {} 已被处理\n", request_id);

    semaphore.release(); 
}

int main() {
    // 模拟 10 个并发请求
    std::vector<std::jthread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(handle_request, i);
    }
}
```

- `counting_semaphore` 是一个轻量同步原语，能控制对共享资源的访问。不同于 `std::mutex`，`counting_semaphre` 允许统一资源进行多个并发的访问，**至少**允许 `LeastMaxValue` 个同时访问者。
- `binaary_semaphore` 是 `std::counting_semaphore` 的特化的别名，其 `LeastMaxValue` 为 1。

`LeastMaxValue` 是我们设置的非类型模板参数，意思是信号量维护的计数最大值。我们这段代码设置的是 3，也就是允许 3 个同时访问者。

> 虽然说是说有 `LeastMaxValue` 可能不是最大，但是我们通常不用在意这个事情，MSVC STL 的实现中 max 函数就是直接返回 LeastMaxValue，将它视为信号量维护的计数最大值即可。

牢记信号量的基本的概念不变，计数的值不能小于 0，如果当前信号量的计数值为 0，那么执行“等待”（`acquire`）操作的线程将会一直**阻塞**。明白这点，那么就都不存在问题。

通过这种方式，可以有效控制 Web 服务器处理并发请求的数量，防止服务器过载。









