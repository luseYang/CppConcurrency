# 利用条件变量构造线程安全队列

本文介绍如何使用条件变量控制并发的同步操作，试想有一个线程 A 一直输出 1，另一个线程 B 一直输出 2。我想让两个线程交替输出1，2，1，2...之类的效果，该如何实现？有的同学可能会说不是有互斥量 `mutex` 吗？可以用一个全局变量 `num` 表示应该哪个线程输出，比如 `num` 为 1 则线程 A 输出 1，`num` 为 2 则线程 B 输出 2，`mutex` 控制两个线程访问 `num`，如果 `num` 和线程不匹配，就让该线程睡一会，这不就实现了吗？比如线程 A 加锁后发现当前 `num` 为 2 则表示它不能输出 1，就解锁，将锁的使用权交给线程 A，线程 B 就 `sleep` 一会。

## 错误实现

```cpp
void PoorImpleman() {
    std::thread t1([]() {
        for (;;) {

            {
                std::lock_guard<std::mutex> lock(mtx_num);
                if (num == 1) {
                    std::cout << "thread A print 1....." << std::endl;
                    num++;
                    continue;
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(500));

        }

     });

    std::thread t2([]() {
        for (;;) {

            {
                std::lock_guard<std::mutex> lock(mtx_num);
                if (num == 2) {
                    std::cout << "thread B print 2....." << std::endl;
                    num--;
                    continue;
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(500));

        }

        });

    t1.join();
    t2.join();
}void PoorImpleman() {
    std::thread t1([]() {
        for (;;) {

            {
                std::lock_guard<std::mutex> lock(mtx_num);
                if (num == 1) {
                    std::cout << "thread A print 1....." << std::endl;
                    num++;
                    continue;
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(500));

        }

     });

    std::thread t2([]() {
        for (;;) {

            {
                std::lock_guard<std::mutex> lock(mtx_num);
                if (num == 2) {
                    std::cout << "thread B print 2....." << std::endl;
                    num--;
                    continue;
                }
            }

            std::this_thread::sleep_for(std::chrono::milliseconds(500));

        }

        });

    t1.join();
    t2.join();
}
```

`PoorImpleman` 虽然能实现我们交替打印的功能，会造成消息处理的不及时，因为线程 A 要循环检测 `num` 值，如果 `num` 不为 1，则线程 A 就睡眠了，在线程 A 睡眠这段时间很可能B已经处理完打印了，此时 A 还在睡眠，是对资源的浪费，也错过了最佳的处理时机。所以我们提出了用条件变量来通知线程的机制，当线程 A 发现条件不满足时可以挂起，等待线程 B 通知，线程 B 通知 A 后，A 被唤醒继续处理。

## 条件变量

```cpp
void ResonableImplemention() {
    std::thread t1([]() {
        for (;;) {

            std::unique_lock<std::mutex> lock(mtx_num);
            cvA.wait(lock, []() {
                return num == 1;
                });

            num++;
            std::cout << "thread A print 1....." << std::endl;
            cvB.notify_one();
        }

        });

    std::thread t2([]() {
        for (;;) {

            std::unique_lock<std::mutex> lock(mtx_num);
            cvB.wait(lock, []() {
                return num == 2;
                });

            num--;
            std::cout << "thread B print 2....." << std::endl;
            cvA.notify_one();
        }

        });

    t1.join();
    t2.join();
}
```

当条件不满足时(num 不等于1 时) `cvA.wait` 就会挂起，等待线程 B 通知通知线程 A 唤醒，线程 B 采用的是 `cvA.notifyone`。 这么做的好处就是线程交替处理非常及时。比起 `sleep` 的方式，我们可以从控制台上看出差异效果，`sleep` 的方式看出日志基本是每隔 1 秒才打印一次，效率不高。

# 线程安全的队列

```cpp
#include <queue>
#include <mutex>
#include <condition_variable>
template<typename T>
class threadsafe_queue
{
private:
    std::mutex mut;
    std::queue<T> data_queue;
    std::condition_variable data_cond;
public:
    void push(T new_value)
    {
        std::lock_guard<std::mutex> lk(mut);
        data_queue.push(new_value);
        data_cond.notify_one();
    }
    void wait_and_pop(T& value)
    {
        std::unique_lock<std::mutex> lk(mut);
        data_cond.wait(lk,[this]{return !data_queue.empty();});
        value=data_queue.front();
        data_queue.pop();
    }
};

threadsafe_queue<data_chunk> data_queue;    
void data_preparation_thread()
{
    while(more_data_to_prepare())
    {
        data_chunk const data=prepare_data();
        data_queue.push(data);    ⇽---  ②
    }
}
void data_processing_thread()
{
    while(true)
    {
        data_chunk data;
        data_queue.wait_and_pop(data);   
        process(data);
        if(is_last_chunk(data))
            break;
    }
}
```



























































