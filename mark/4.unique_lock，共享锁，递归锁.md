# unique_lock

`unique_lock` 和 `lock_guard` 基本用法相同，构造时默认加锁，析构时默认解锁，但 `unique_lock` 有个好处就是**可以手动解锁**。这一点尤为重要，方便我们控制锁住区域的*粒度(加锁的范围大小)*,也能支持和条件变量配套使用

```cpp
//unique_lock 基本用法
std::mutex mtx;
int shared_data = 0;
void use_unique() {
    //lock可自动解锁，也可手动解锁
    std::unique_lock<std::mutex> lock(mtx);
    std::cout << "lock success" << std::endl;
    shared_data++;
    lock.unlock();
}
```

我们可以通过 `unique_lock` 的 `owns_lock` 判断是否持有锁

```cpp
//可判断是否占有锁
void owns_lock() {
    //lock可自动解锁，也可手动解锁
    std::unique_lock<std::mutex> lock(mtx);
    shared_data++;
    if (lock.owns_lock()) {
        std::cout << "owns lock" << std::endl;
    }
    else {
        std::cout << "doesn't own lock" << std::endl;
    }

    lock.unlock();
    if (lock.owns_lock()) {
        std::cout << "owns lock" << std::endl;
    }
    else {
        std::cout << "doesn't own lock" << std::endl;
    }
}
```

`unique_lock` 还可以延迟加锁

```cpp
 //可以延迟加锁
void defer_lock() {
    //延迟加锁
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);
    //可以加锁
    lock.lock();
    //可以自动析构解锁，也可以手动解锁
    lock.unlock();
}
```













